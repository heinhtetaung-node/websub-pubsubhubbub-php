<feed xmlns="http://www.w3.org/2005/Atom">
	<title>Superfeedr Blog</title>
	<link href="http://178.128.84.21/feed.xml" rel="self" type="application/atom+xml"/>
	<link href="http://178.128.84.21" rel="alternate" type="text/html"/>
	<link rel="hub" href="http://pubsubhubbub.superfeedr.com/"/>
	<updated>2019-05-12T20:33:21-04:00</updated>
	<id>http://blog.superfeedr.com/</id>

	<entry>
		<title>Updated Pricing456</title>
		<link href="http://blog.superfeedr.com/updated-pricing/"/>
		<published>2017-02-06T00:00:00-05:00</published>
		<updated>2017-02-06T00:00:00-05:00</updated>
		<id>blog.superfeedr.com:/updated-pricing</id>
		<summary>
			Our new pricing is based on the number of subscriptions that Superfeedr is handling for you. The first 10 feeds are always free.
		</summary>
		<content type="html">
			<p>Today, we are introducing a <strong>new pricing</strong> for Superfeedr’s subscribers.</p> <p>In our early days, we wanted Superfeedr’s pricing to be based on the amount of data our service would send you. As we were very young start-up, we made the assumption that verbose feeds would cost us more to process and that it would be fair to pass this cost down to customers. In retrospect, this was not the best approach as it means that our pricing was less predictable than it should be: <em>subscribers do not control how verbose the feeds they’re subscribed to are</em>.</p> <p>As the <a href="http://blog.superfeedr.com/google-feed-api-gone/">Google Feed API is gone</a>, a lot of our most recent customer are only using <a href="http://blog.superfeedr.com/ways-to-use-superfeedr/">our “pull” APIs</a>. This means that they often have no visibility in the number of update for any given feed. This is another reason to reconsider our pricing.</p> <p>Our new approach is to charge our subscribers based on the number of feeds we process on their behalf. We analysed subscriber accounts and the recent invoices and came up with this beautiful scatter graph which allowed us to determine what would be the right breakdown.</p> <p><img src="http://blog.superfeedr.com/images/price-per-subscription.png" style="" /></p> <p>And here are the rules we will be applying to all new subscriber accounts:</p> <ul> <li>10 cts per subscription for the first 50 feeds,</li> <li>5 cts for each feed up to 5,000 feeds,</li> <li>2 cts for each feed up to 50,000 feeds,</li> <li>1 ct per feed for each feed beyond that.</li> </ul> <p>You can also use <a href="https://superfeedr.com/subscriber#pricing">our simulator</a> for a more detailed estimation.</p> <p>Additionally, if your invoice is less than $1, we will waive it; this means that the <strong>first 10 feeds are always free</strong>.</p> <p>Finally, even though this pricing should almost always mean lower invoices for our existing customers, we offer them the ability to remain on the current pricing for as long as they want.</p>
		</content>
		<author>
			<name>Julien</name>
			<uri>http://ouvre-boite.com</uri>
		</author>
	</entry>



	<entry>
		<title>Updated Pricing123</title>
		<link href="http://blog.superfeedr.com/updated-pricing/"/>
		<published>2017-02-06T00:00:00-05:00</published>
		<updated>2017-02-06T00:00:00-05:00</updated>
		<id>blog.superfeedr.com:/updated-pricing</id>
		<summary>
			Our new pricing is based on the number of subscriptions that Superfeedr is handling for you. The first 10 feeds are always free.
		</summary>
		<content type="html">
			<p>Today, we are introducing a <strong>new pricing</strong> for Superfeedr’s subscribers.</p> <p>In our early days, we wanted Superfeedr’s pricing to be based on the amount of data our service would send you. As we were very young start-up, we made the assumption that verbose feeds would cost us more to process and that it would be fair to pass this cost down to customers. In retrospect, this was not the best approach as it means that our pricing was less predictable than it should be: <em>subscribers do not control how verbose the feeds they’re subscribed to are</em>.</p> <p>As the <a href="http://blog.superfeedr.com/google-feed-api-gone/">Google Feed API is gone</a>, a lot of our most recent customer are only using <a href="http://blog.superfeedr.com/ways-to-use-superfeedr/">our “pull” APIs</a>. This means that they often have no visibility in the number of update for any given feed. This is another reason to reconsider our pricing.</p> <p>Our new approach is to charge our subscribers based on the number of feeds we process on their behalf. We analysed subscriber accounts and the recent invoices and came up with this beautiful scatter graph which allowed us to determine what would be the right breakdown.</p> <p><img src="http://blog.superfeedr.com/images/price-per-subscription.png" style="" /></p> <p>And here are the rules we will be applying to all new subscriber accounts:</p> <ul> <li>10 cts per subscription for the first 50 feeds,</li> <li>5 cts for each feed up to 5,000 feeds,</li> <li>2 cts for each feed up to 50,000 feeds,</li> <li>1 ct per feed for each feed beyond that.</li> </ul> <p>You can also use <a href="https://superfeedr.com/subscriber#pricing">our simulator</a> for a more detailed estimation.</p> <p>Additionally, if your invoice is less than $1, we will waive it; this means that the <strong>first 10 feeds are always free</strong>.</p> <p>Finally, even though this pricing should almost always mean lower invoices for our existing customers, we offer them the ability to remain on the current pricing for as long as they want.</p>
		</content>
		<author>
			<name>Julien</name>
			<uri>http://ouvre-boite.com</uri>
		</author>
	</entry>

	<entry>
		<title>Updated Pricing</title>
		<link href="http://blog.superfeedr.com/updated-pricing/"/>
		<published>2017-02-06T00:00:00-05:00</published>
		<updated>2017-02-06T00:00:00-05:00</updated>
		<id>blog.superfeedr.com:/updated-pricing</id>
		<summary>
			Our new pricing is based on the number of subscriptions that Superfeedr is handling for you. The first 10 feeds are always free.
		</summary>
		<content type="html">
			<p>Today, we are introducing a <strong>new pricing</strong> for Superfeedr’s subscribers.</p> <p>In our early days, we wanted Superfeedr’s pricing to be based on the amount of data our service would send you. As we were very young start-up, we made the assumption that verbose feeds would cost us more to process and that it would be fair to pass this cost down to customers. In retrospect, this was not the best approach as it means that our pricing was less predictable than it should be: <em>subscribers do not control how verbose the feeds they’re subscribed to are</em>.</p> <p>As the <a href="http://blog.superfeedr.com/google-feed-api-gone/">Google Feed API is gone</a>, a lot of our most recent customer are only using <a href="http://blog.superfeedr.com/ways-to-use-superfeedr/">our “pull” APIs</a>. This means that they often have no visibility in the number of update for any given feed. This is another reason to reconsider our pricing.</p> <p>Our new approach is to charge our subscribers based on the number of feeds we process on their behalf. We analysed subscriber accounts and the recent invoices and came up with this beautiful scatter graph which allowed us to determine what would be the right breakdown.</p> <p><img src="http://blog.superfeedr.com/images/price-per-subscription.png" style="" /></p> <p>And here are the rules we will be applying to all new subscriber accounts:</p> <ul> <li>10 cts per subscription for the first 50 feeds,</li> <li>5 cts for each feed up to 5,000 feeds,</li> <li>2 cts for each feed up to 50,000 feeds,</li> <li>1 ct per feed for each feed beyond that.</li> </ul> <p>You can also use <a href="https://superfeedr.com/subscriber#pricing">our simulator</a> for a more detailed estimation.</p> <p>Additionally, if your invoice is less than $1, we will waive it; this means that the <strong>first 10 feeds are always free</strong>.</p> <p>Finally, even though this pricing should almost always mean lower invoices for our existing customers, we offer them the ability to remain on the current pricing for as long as they want.</p>
		</content>
		<author>
			<name>Julien</name>
			<uri>http://ouvre-boite.com</uri>
		</author>
	</entry>
	<entry>
		<title>Google Feed API is gone: now what?</title>
		<link href="http://blog.superfeedr.com/google-feed-api-gone/"/>
		<published>2016-12-12T00:00:00-05:00</published>
		<updated>2016-12-12T00:00:00-05:00</updated>
		<id>blog.superfeedr.com:/google-feed-api-gone</id>
		<summary>
			Switch to Superfeedr for the API and Embedly for the embeds.
		</summary>
		<content type="html">
			<p>As you <a href="https://blog.superfeedr.com/google-feed-api-alternative/">might have heard</a>, the <strong>Google Feed API</strong> is closing on December 15th, 2016. It’s not too late to look for a replacement and Superfeedr has you covered, either directly, or via Embedly.</p> <p>The Google Feed API was used to build all types of applications, from simple web page embeds to more advanced feed readers and podcasts players. <a href="https://superfeedr.com">Superfeedr</a> is a powerful replacement which also provides tools for all of these use cases. We also have solutions for feed <a href="https://superfeedr.com/publisher">publishers</a> or even for people looking for <a href="https://superfeedr.com/tracker">real-time search filters</a>.</p> <blockquote> <p>Compared to the Google Feed API, we provide a <a href="http://documentation.superfeedr.com/schema.html">richer schema</a> (with <a href="https://blog.superfeedr.com/more-metadata/">more metadata</a>!).</p> </blockquote> <h2 id="push-vspull">Push vs. Pull</h2> <p>One of the largest benefits of using Superfeedr’s infrastructure is that rather than polling data from us, you can <strong>subscribe</strong> to the feeds and be notified using <strong>webhooks</strong> when these are updated. That means you do not have to load data from Superfeedr on your web pages, but can conveniently store it on your server and serve it from there.</p> <h2 id="embedding-feeds">Embedding feeds</h2> <p>In addition to consuming feeds, if you’re looking to <em>embed feeds</em>, consider using <a href="http://embed.ly/">Embedly</a>. Embedly is a Superfeedr customer and the processing of feeds is handled transparently by us.</p> <p>Their embed is very simple to configure and is responsive which means it will look great on both desktop and mobile web. Here’s an example with the feed for <a href="https://blog.superfeedr.com/">this blog</a> (you can replace the value of the <code>href</code> attribute with any feed):</p> <pre data-line=""><code class="language-markup">&lt;a class=&quot;embedly-card&quot; href=&quot;https://superfeedr-blog-feed.herokuapp.com/&quot;&gt;Feed&lt;/a&gt; &lt;script async src=&quot;//cdn.embedly.com/widgets/platform.js&quot; charset=&quot;UTF-8&quot;&gt;&lt;/script&gt;</code></pre> <p>And here is the output:</p> <p><a class="embedly-card" href="https://superfeedr-blog-feed.herokuapp.com/">Feed</a> <script async="" src="http://blog.superfeedr.com//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script></p>
		</content>
		<author>
			<name>Julien</name>
			<uri>http://ouvre-boite.com</uri>
		</author>
	</entry>
	<entry>
		<title>Building a News Bot for Facebook Messenger</title>
		<link href="http://blog.superfeedr.com/news-bot-rss-facebook-messenger/"/>
		<published>2016-11-01T00:00:00-04:00</published>
		<updated>2016-11-01T00:00:00-04:00</updated>
		<id>
			blog.superfeedr.com:/news-bot-rss-facebook-messenger
		</id>
		<summary>
			We built a news bot Facebook Messenger which lets you follow you favorite websites and be notified when they publish new stories.
		</summary>
		<content type="html">
			<p>With each month that goes by, there is less and less doubt that messaging applications and bots are one of the interfaces with whom we are interacting more and more. One of the verticals for which messaging applications are the most useful is news.</p> <p>We built a news bot Facebook Messenger which lets you follow you favorite websites and be notified when they publish new stories.</p> <h2 id="try-it-first">Try it first</h2> <p>If you have a Facebook account, you should start by testing the news bot to see what it’s capable of. It’s as easy as <a href="https://m.me/superfeedr">opening this link</a>. You should now be able to start a conversation with Superfeedr’s bot. First I usually say <em>Hello</em>.</p> <p>The bots let you then type (or paste really), the URL of your favorite site. I chose <a href="https://medium.com/superfeedr-thoughts">Superfeedr’s Medium publication</a> so I typed <code>http://medium.com/superfeedr-thoughts</code>. The bot then uses <a href="http://feediscovery.appspot.com/">Feediscovery</a> to find an relevant RSS feed and asks for a final confirmation. Once this is all set, the next time the publication publishes something, you should get a message from the bot to read that story.</p> <p>This is a pretty simple bot but already does wonders!</p> <h2 id="how-we-built-it">How we built it</h2> <p>The quick answer is that we took the exact same code base that we used for <a href="https://blog.superfeedr.com/rss-bot-telegram-lambda/">Telegram bot we built last year</a>. It also runs on Amazon’s Lambda infrastructure which, even if it is complex to set up is <strong>perfect of webhook based services</strong>.</p> <p>The whole bot code is <a href="https://github.com/superfeedr/news-bot">available on Github</a>.</p> <h3 id="setting-things-up-on-facebook">Setting things up on Facebook.</h3> <p>First, we have to <a href="https://developers.facebook.com/">build a Facebook application</a>. You also need a Facebook page as Facebook’s Messenger bots are linked to a page.</p> <p>Switch to the Messenger settings and start by generating a token that you’ll use to send requests to the Facebook API. For this, you need to select the page that users will interact with. Copy this token to the settings <a href="https://github.com/superfeedr/news-bot/blob/master/src/_init.js">in the <code>init</code> file</a>.</p> <p><img src="http://blog.superfeedr.com/images/facebook-news-bot/token-generation.png" alt="Generate Token" /></p> <p>Then, you have to configure the webhooks for incoming messages.</p> <p>The base URL is where our service will be deployed (you should use an Amazon Lambda URL if you’re deploying your bot there). Our code routes incoming webhooks using the <code>platform</code> query string parameter.</p> <p>We also specify the types of messages we want to receive: <code>message_deliveries</code>, <code>messages</code>, <code>messaging_optins</code>, <code>messaging_postbacks</code>.</p> <p>Facebook will send a verification of intent request (PubSubHubbub FTW!) and you should set a random verification token: the bot’s code should handle that by default.</p> <p><img src="http://blog.superfeedr.com/images/facebook-news-bot/facebook-webhooks-settings.png" alt="Webhook Settings" /></p> <p>After that you should be all set.</p> <p><small>Feel free to follow the <a href="https://developers.facebook.com/docs/messenger-platform/guides/quick-start">quick start instructions</a> in Facebook’s docs for more details.</small></p> <h3 id="architecture-overview">Architecture overview</h3> <p>The news bot code is routing incoming events based on the <code>platform</code> query string value. Each message is sent to the right platform handler to be parsed. Each of these platform handlers (Facebook and Telegram for now) implements a <code>parseChatMessage</code> method which yields back to the main router.</p> <p>The main router then identifies the command. We currently support the following commands: <em>hello</em>, <em>help</em>, <em>list</em>, <em>subscribe</em>, <em>unsubscribe</em>, <em>url</em> and <em>version</em>. Once they have been executed; they themselves call the platforms to send back messages to users. By using this, we can let <strong>each platform implement its own specific features</strong>, such as buttons or custom keyboards.</p> <p>When a user starts to follow a feed, we issue a <a href="https://documentation.superfeedr.com/subscribers.html#adding-feeds-with-pubsubhubbub">subscription request to Superfeedr</a>. The callback URL used for these subscriptions includes the <code>platform</code> as well as a unique <code>chatId</code> to identify the exact user who should receive the data. By doing this, we <strong>do not have to store any state inside our bot</strong>, making the webhook pattern trivial to scale.</p> <p>Finally, when Superfeedr sends a notification to the news bot, we extract the platform and chat id from the callback URL, as well as the content of the message and invoke the platform’s <code>sendMessage</code> method.</p> <h3 id="the-future">The future</h3> <p>Adding support for more platforms such as Slack or Kik should be fairly simple. We could also start adding more commands such as <code>track</code> to implement the <a href="https://documentation.superfeedr.com/trackers.html">tracker capabilities of Superfeedr</a>.</p> <p>Please, let us know what you think! You’re more than welcome to fork the code!</p>
		</content>
		<author>
			<name>Julien</name>
			<uri>http://ouvre-boite.com</uri>
		</author>
	</entry>
	<entry>
		<title>Medium acquires Superfeedr</title>
		<link href="http://blog.superfeedr.com/medium-acquires-superfeedr/"/>
		<published>2016-06-02T00:00:00-04:00</published>
		<updated>2016-06-02T00:00:00-04:00</updated>
		<id>blog.superfeedr.com:/medium-acquires-superfeedr</id>
		<summary>
			Publishing on the web is changing drastically. Medium is one of these few companies which are building the future of publishing and reading. We're excited to join forces with them and continue building the open web in this new era!
		</summary>
		<content type="html">
			<p>The web is very different from what it was 8 years ago. We’ve <a href="https://blog.superfeedr.com/instant-articles-future-rss/">said it</a> <a href="https://blog.superfeedr.com/apple-facebook-rss/">several</a> <a href="https://blog.superfeedr.com/it-is-called-rss/">times</a>: publishing and consuming content are <strong>new frontiers</strong> for most of the web giants like Facebook, Google or Apple. We consume the web from mobile devices, we discover content on silo-ed social networks and, more importantly, the base metaphor for <a href="http://www.ouvre-boite.com/space-to-time/">the web is shifting from “space” to “time”</a>.</p> <p><a href="https://superfeedr.com">Superfeedr</a>, the <strong>open web’s leading feed API</strong> and PubSubHubbub hub has been an independent player for 8 years. Superfeedr exists in order to enable people to exchange information on the web more freely and easily. Today, we’re excited to announce Superfeedr has been acquired by <a href="https://medium.com">Medium</a>. In many ways, it’s a very natural fit: Medium wants to create the best place to publish, distribute and consume content on the web. Together, we are hoping to keep Medium the company a leader in good industry practices, and Medium the network a place where this conversation can gain even more traction.</p> <p>At Superfeedr, we’ve promoted the open web by embracing open formats and protocols, such as RSS, Atom, XMPP and PubSubHubbub. Over the years, we’ve also learned that these protocols are only as powerful as the people who promote them. As we want the open web to remain strong, we were delighted to find that the folks at Medium share the same values. And we think that Superfeedr’s acquisition is a powerful indicator of Medium’s support for open protocols. As an example of this, my first commit at Medium was to enable full content RSS feeds both for publications and users (available <a href="https://medium.com/me/settings">in your settings</a>). Medium already lets you add your own domain name, import and export all of your posts, point to a canonical URL if you cross-posted, supports DNT… and we’ve started working on more!</p> <p>If you are a Superfeedr customer, <strong>nothing has changed</strong>: it’s business as usual. More than ever, we are dedicated to providing you with a convenient way to <em>consume</em> or <em>publish feeds</em> from all over the web using open protocols as well as <a href="https://superfeedr.com/tracker">tracking keywords in real time</a>.</p> <p>Finally, I also want to take a couple moments to thank all the Superfeedr family: the numerous contractors with whom we’ve worked over the years, our investors (<a href="https://betaworks.com">Betaworks</a> and <a href="https://twitter.com/mcuban">Mark Cuban</a>), as well as our advisors and partners.</p> <p>I’m confident Medium is the right home for Superfeedr. The team here is one of the most talented I’ve ever met and we’re already leading the way when it comes to enabling amazing content publishing. Every month, people collectively spend 2,000,000 hours reading these stories, and I’m delighted to be part of the team building this!</p>
		</content>
		<author>
			<name>Julien</name>
			<uri>http://ouvre-boite.com</uri>
		</author>
	</entry>
	<entry>
		<title>
			Focus on the Front-End: Building an Asset Repository
		</title>
		<link href="http://blog.superfeedr.com/new-assets/"/>
		<published>2016-04-05T00:00:00-04:00</published>
		<updated>2016-04-05T00:00:00-04:00</updated>
		<id>blog.superfeedr.com:/new-assets</id>
		<summary>
			Change is afoot in Superfeedr’s websites—change in the form of patterns, centralization, and standardization.
		</summary>
		<content type="html">
			<p>Change is afoot in Superfeedr’s websites—change in the form of patterns, centralization, and standardization.</p> <p>In the summer of 2014, a team from <a href="https://www.vanpattenmedia.com/">Van Patten Media Inc.</a>—in this case, <a href="http://www.chrisvanpatten.com">Chris Van Patten</a> and <a href="http://lucascherkewski.com">myself</a>—worked with Julien here at Superfeedr to <a href="https://blog.superfeedr.com/new-design/">redesign the application’s web interface</a>. We updated a dated design, surfacing functionality that was previously hidden, and made it easier for people new to Superfeedr to figure out just how great it is. The Van Patten Media team also worked on the public-facing elements of the website, redesigning the marketing site, documentation, and blog from the ground up.</p> <p>We were happy with the results of these redesign projects, and were excited at the opportunity to work with Julien again on a new project: developing a centralized asset repository and pattern library for all Superfeedr web properties.</p> <h2 id="project-goals">Project goals</h2> <p>We had a few key goals with this latest project:</p> <ul> <li>Develop a repository that all properties could pull from, centrally-updated so that improvements were shared;</li> <li>Cut down on redundancy and push for more consistency across the interfaces;</li> <li>Document all the patterns in use across Superfeedr’s various sites;</li> <li>Make it easier to design new pages or properties in the future.</li> </ul> <p>We’re happy to say that, after a few weeks of work, we’ve accomplished these goals! With all these new changes, there are a few in particular that we want to highlight and dig into a little further.</p> <h2 id="patterns-patterns-patterns">Patterns, patterns, patterns</h2> <p>Whether you call it a pattern library or a style guide, this method of development and documentation has increased in popularity over the last few years, and for good reason: it encourages and rewards modular thinking in terms of markup, styles, and functionality for front-end components.</p> <p>When we set out on our initial redesign of Superfeedr back in in 2014, our first code took place in a small <code>patterns.html</code> file. We didn’t set out to create a proper “pattern library” on day one, but having this file made it easier to see a collection of components in one place and, as we started to design full pages, simplified the work by letting us copy and paste.</p> <p>This initial, informal pattern library was brought out again as we started working on this most recent project. Because a key goal for the project was to create a “centralised repo” for our assets, we knew we’d have to combine stylesheets from a few sources. A structured, formal pattern library would help prevent us from missing key modules or duplicating code as we merged the assets into one canonical source.</p> <p>We evaluated a number of open source pattern documentation tools, but eventually landed on a custom approach. We gave each pattern its own HTML file, and loaded each one into an <code>&lt;iframe&gt;</code> in the final output via a build process powered by <a href="https://github.com/coderhaoxin/gulp-file-include"><code>gulp-file-include</code></a>, using the <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-srcdoc"><code>srcdoc</code></a> attribute. This ensured that each pattern could function in isolation, unaffected by other modules or the pattern library itself.</p> <p>We also added a brief description and usage notes for each pattern, so that anyone looking to extend Superfeedr in the future could easily understand which patterns to use, and how. We built, in essence, <a href="http://daverupert.com/2013/04/responsive-deliverables/#tiny-bootstraps-for-every-client">a tiny Bootstrap</a> for Superfeedr’s use—and you can <a href="https://assets.superfeedr.com">view it yourself, too!</a></p> <p>Making this pattern library helped us find parts of the design that were redundant, buggy, or less than ideal, and fix them to a known-good standard—fitting, given Superfeedr’s huge support for standards-based applications! Even though Superfeedr is just one entity, its four properties now stand that much more unified thanks to the documentation and implementation of these patterns, and any future expansions of the service can be quickly designed and implemented.</p> <h2 id="bootstrap-compatibility">Bootstrap compatibility</h2> <p>When Julien developed <a href="https://blog.superfeedr.com/river-news/">river.news</a>, he wanted to show off Superfeedr’s capabilities in an application that could be plugged into many websites and just work. When he did this, he styled the markup with Bootstrap classes, knowing that many websites use Bootstrap, so that if River.news was embedded on a site already using Bootstrap, it’d look great. However, he also wanted code styled with Bootstrap classes displayed on a Superfeedr property to look and feel like Superfeedr.</p> <p>After evaluating a few options, and some conceptual tug-of-war as we tried to determine the most efficient way to do this, we settled on Sass <a href="http://sass-lang.com/guide#topic-7"><code>@extend</code>s</a>, which allow you to apply the styles from one CSS rule to another.</p> <p>For example, here’s how we mapped Bootstrap’s inimitable button classes:</p> <pre data-line=""><code class="language-css">.btn { @extend .button; } .btn-default, .btn-info, .btn-primary, .btn-success, .btn-warning, .btn-danger { @extend .button--raised; } .btn-default, .btn-info { @extend .button--neutral; } .btn-primary, .btn-success { @extend .button--positive; }</code></pre> <p>…and so on.</p> <p>As you can see, we were able to avoid duplicating the actual rules by mapping our existing styles to the Bootstrap class names.</p> <p>As we worked on this feature, we had a number of discussions (between ourselves and with Julien) about this particular requirement. It’s an interesting challenge: how do you make an embeddable module look “native” in as many contexts as possible? We settled on this Bootstrap “map”, but there are other approaches as well. We like the look of <a href="http://glenmaddern.com/articles/css-modules">CSS modules</a>, which allow you to automatically namespace and modularise CSS within a given widget. CSS modules are designed for large CSS codebases, but could also allow projects like River.news to provide “mappings” to frameworks like Bootstrap or Foundation, and allow users to swap between them without requiring multiple sets of markup. It would also make it easier for users to provide custom CSS that fits within their unique design.</p> <p>We also realised the importance of good documentation of classes and markup. Even if not using a standardized CSS class structure—like BEM, OOCSS, SMACSS, or so on—adopting standard conventions for HTML structure and class names in your project can make it easier for others to adapt your work to their particular use case, without needing to fork it or reinvent the wheel.</p> <p>Markup underlies all the work we do on the web, and being sensible about its form will go a long way towards increasing the interoperability of our various components.</p> <h2 id="conclusion">Conclusion</h2> <p>It has been a thrill to work with Julien on a service that’s so important to so many organisations and projects around the web. Superfeedr stands for open protocols, open software, and open communications—which is why we were so excited to write this post and document our efforts.</p> <p>Working with Julien on Superfeedr has been a fantastic experience, and we’re proud of the results of this project: we created a pattern library and central assets repository that drives all of the Superfeedr web properties, and will make it much easier to update them or make new ones in the future. We’re excited to see where Julien takes Superfeedr next!</p>
		</content>
		<author>
			<name>Lucas</name>
			<uri>http://lucascherkewski.com</uri>
		</author>
	</entry>
	<entry>
		<title>Embed and customize River.news </title>
		<link href="http://blog.superfeedr.com/embed-river-news/"/>
		<published>2016-03-30T00:00:00-04:00</published>
		<updated>2016-03-30T00:00:00-04:00</updated>
		<id>blog.superfeedr.com:/embed-river-news</id>
		<summary>
			River.news is a very basic feed reader which can be embedded on any we page
		</summary>
		<content type="html">
			<p>The <a href="https://superfeedr.com/">superfeedr feed API</a> is quite powerful and lets anyone build any kind of application which consumes RSS feeds, whether it’s on the web, a mobile application, or processed on the server side. Building and maintaining servers is not always trivial, which is why more and more applications are built to be server-less. This is the case of our <a href="https://river.news">river.news</a> app. We recently updated it and here’s a breakdown of what it does.</p> <p>Not only you can use <a href="https://river.news">River.news</a> on its own domain, but you can also effortlessly embed on any HTML page… <a href="#rivernews">like this one</a>:</p> <h2 id="offline-service-workers">Offline: Service Workers</h2> <p>If you read this blog often, you’ve already seen that <a href="https://blog.superfeedr.com/service-workers/">we added offline support to river.news</a>. Service Workers are completely changing the web from a document-oriented architecture (HTML pages are loaded first) to an <strong>application-oriented architecture</strong> with javascript executed even before HTTP requests are fired.</p> <h2 id="better-styling">Better styling</h2> <p>Recently, we centralised all of our styling assets on <a href="https://assets.superfeedr.com/">assets.superfeedr.com</a>. The fantastic team at <a href="https://www.vanpattenmedia.com/">Van Patten Media</a> did an amazing work to group, document and simplify all the assets used by Superfeedr. Our river.news now uses these assets by default. Also, since we use the bootstrap classes, including Bootstrap’s CSS will yield a nice looking style to your instance of river.news!</p> <h2 id="customisable">Customisable</h2> <p>Finally, the most recent version of river.news lets you hard-code a login and token. You can also prevent the visitor from changing the subscription list. For example, the river embedded above has disable the ability to enter a superfeedr login and password, as well as the ability to subscribe to new feeds. The configuration happens in the DOM, with <code>data-attributes</code>.</p> <p>There’s a lot more to do! What features are important to you in an embeddable feed reader?</p> <div id="rivernews" data-superfeedr-login="superfeedr" data-superfeedr-token="1a8c661804873703802212503e75d3c2" data-disable-settings="" data-disable-subscriptions=""></div>
		</content>
		<author>
			<name>Julien</name>
			<uri>http://ouvre-boite.com</uri>
		</author>
	</entry>
	<entry>
		<title>Instant Articles and the future of RSS</title>
		<link href="http://blog.superfeedr.com/instant-articles-future-rss/"/>
		<published>2016-03-01T00:00:00-05:00</published>
		<updated>2016-03-01T00:00:00-05:00</updated>
		<id>blog.superfeedr.com:/instant-articles-future-rss</id>
		<summary/>
		<content type="html">
			<p>In the past couple months, a lot has been happening on the <em>syndication</em> front. The mobile and social worlds have become more and more aware of the importance of the <strong>open web</strong> and we’ve seen several new efforts to improve the user experience on these fronts.</p> <h2 id="mobile">Mobile</h2> <p>Despite increasing bandwidth, the constraints of the mobile internet are still extremely tight: latency, spotty connections, limited memory and power… etc. The <a href="http://idlewords.com/talks/website_obesity.htm">web’s constant growth</a> when it comes to page size, number of loaded resources and the need for more and more beams and advertisement have been colliding with this.</p> <h2 id="social">Social</h2> <p>In parallel, more than ever, we discover our content through the filter of the social networks. A couple months ago, our friends at Parsely shared that <a href="https://blog.parsely.com/post/2296/facebook-dominates-referral-traffic-a-coverage-overview/">Facebook was dominating the referral traffic</a>. The actual mileage varies from site to site, but it’s obvious that the golden days of SEO and search-engine based discovery are behind us.</p> <h2 id="space-vs-time">Space vs. Time</h2> <p>Another, more massive trend is supported by these 2: the <a href="http://www.ouvre-boite.com/space-to-time/">web is going toward a spatial organisation toward a time-based organization</a>: time-lines have replaced site-maps and URLs are slowly being hidden from the user interfaces: where we consume the content is less important than what it was.</p> <h2 id="syndication-rebooted">Syndication rebooted</h2> <p><a href="https://instantarticles.fb.com/">Instant Articles</a> are Facebook’s answer to these trends. (So is <a href="https://www.ampproject.org/">Google’s AMP</a>). In practice, these HTML documents are <strong>embedded inside RSS feeds</strong> so that Facebook can easily import the web’s content into its apps. Like RSS, they’re <em>not as rich as full HTML document</em>. For example, they can’t include scripts or styles. They also require a certain number of elements which would be optional with HTML.</p> <p>On their end, Facebook will <strong>replicate</strong> the content of the publisher’s site, using the Instant Article format. Each open web URL is mapped to an Instant Article inside Facebook. This is what lets them serve content much faster as they are in charge of caching and content delivery. The consequence of this approach is that once a publisher starts supporting Instant Articles, Facebook will show the Instant Article version of the content <strong>as soon as anyone shares a link to this site</strong>. You don’t have to share the links from a Facebook page : any link to the content will be served as its Instant Article version.</p> <p>Some may be scared by this which results in building a <strong>shadow web</strong>, inside Facebook, but I’d like to to highlight a couple things:</p> <ul> <li>This is exactly how RSS has worked since it was conceived</li> <li>This is also how <a href="https://www.ampproject.org/">Google’s AMP</a> work except that of course, in this case, Google’s cache is applied</li> <li>Anyone, not just Facebook, could also cache the Instant Article version of the pages shared on their platform.</li> </ul> <p>You guessed it: at <a href="https://superfeedr.com">Superfeedr</a>, we’re evaluating this final and last point. Exactly <a href="http://blog.superfeedr.com/bridging-amp-and-rss/">like for Google’s AMP</a>, we’re working on supporting Facebook’s Instant Article as a subscription format so that when you subscribe to a feed, you could request to only be notified with the Instant Article version of content, if it’s available.</p>
		</content>
		<author>
			<name>Julien</name>
			<uri>http://ouvre-boite.com</uri>
		</author>
	</entry>
	<entry>
		<title>Full Text RSS</title>
		<link href="http://blog.superfeedr.com/full-text-rss/"/>
		<published>2016-01-28T00:00:00-05:00</published>
		<updated>2016-01-28T00:00:00-05:00</updated>
		<id>blog.superfeedr.com:/full-text-rss</id>
		<summary>
			Truncating RSS feeds is probably the worse a publisher can do: it degrades the experience of savvy users who chose to follow the RSS feed.
		</summary>
		<content type="html">
			<p>Of course, if your website publishes content, you should <strong>absolutely publish RSS feeds</strong> (or Atom feeds, <a href="http://blog.superfeedr.com/gospel/feeds/atom-or-rss-not-both/">but not both</a>!). Luckily, a lot of publishers eventually do, even if they sometimes have trouble dealing with <a href="http://blog.superfeedr.com/rss-autodiscovery/">auto-discovery</a>. However, a lot of these publishers will publish <em>truncated</em> RSS feeds, and that’s generally a bad idea.</p> <p>The main reason publishers truncate their feeds is that they expect the subscribers want to visit the “original” site and then view its ads or interact with the content more… Other publishers fear that full text RSS feeds can be used by scrapers to duplicate content and rank better in search engine. Let’s face it: if somebody wants to duplicate content, there are many more ways than using the RSS feeds.</p> <h2 id="who-uses-rss-feeds">Who uses RSS feeds?</h2> <p>These days, it’s clear that <strong>RSS is mostly used by advanced users</strong>: <a href="http://www.businessinsider.com/feedly-2014-2?IR=T">millions of of them</a>, but still a small fraction of the <a href="http://www.internetlivestats.com/internet-users/">web’s 3+ Bn users</a>. Given the relative complexity of most feed readers when compared to the social web applications, it’s also safe to assume that these users are at least savvy.</p> <p>When it comes to ads, the most savvy web users are often the ones who use ad-blockers. Even when they don’t, they also tend to click less on these banners. So, chances are that <em>even if they clicked</em> in their readers to view the rest of the truncated content, they <strong>won’t even see or click on the ads</strong>.</p> <p>It’s also important to remember that feed reader users <strong>chose</strong> to use a feed reader (many of them actually pay to use the feed reader of their choice). They understand their limitations as well as their benefits. It’s certainly much harder than expected to entice them to click on links <em>away</em> from their readers.</p> <h2 id="the-feed-readers-are-good">The feed readers are good!</h2> <p>Often, feed readers are <strong>offline first</strong> experiences: they aggregate content from multiple sources so that the data can be consumed while commuting, on planes… but more importantly (and more often), the feed reader users <em>don’t have to wait for the data to load</em> for each entry that they’re reading. Generally, feed readers will be able to load all recent stories at once, allowing for a much faster experience when reading story after story.</p> <p>These days, modern feed readers <em>also include a lot of social web features</em> which let their users share the feed’s content, favorite the stories they like the most, and more. By doing this, the feed readers can drive a lot of traffic back to the publisher’s site.</p> <p>Finally, <strong>degrading the experience can sometimes be worse than not providing any RSS feed at all</strong>. These advanced users are certainly very experienced and are also influential. If their experience interacting with the publisher’s content is great, they’re more likely to more of consume it and share it even more.</p>
		</content>
		<author>
			<name>Julien</name>
			<uri>http://ouvre-boite.com</uri>
		</author>
	</entry>
	<entry>
		<title>Hijacking API requests with Service Workers</title>
		<link href="http://blog.superfeedr.com/hijacking-api-requests-service-worker/"/>
		<published>2016-01-20T00:00:00-05:00</published>
		<updated>2016-01-20T00:00:00-05:00</updated>
		<id>
			blog.superfeedr.com:/hijacking-api-requests-service-worker
		</id>
		<summary>
			The data consumed in a feed reader is updated often. Yet, for the best experience, we want to also serve the cached data.
		</summary>
		<content type="html">
			<p><a href="http://blog.superfeedr.com/service-workers/">Last week</a>, we’ve seen how to add a Service Worker to <a href="https://river.news/">our feed reader</a> so that it loads faster by caching its <em>shell</em>. One of the direct benefits of this is that our application shell is now also <strong>available offline</strong>, even when the browser is not connected to the web.</p> <p>This week, we’ll see how we should also use the Service Worker API to cache the dynamic data coming from the <a href="https://superfeedr.com/">Superfeedr Feed API</a>.</p> <h2 id="service-worker-toolbox">Service Worker Toolbox</h2> <p>Our shell is now cached immediately after the first visit to <a href="https://river.news">River.news</a>. After this, the content of the shell (static HTML, CSS and javascript) are <em>always</em> loaded only from the cache. (until of course we update the service worker). The RSS feeds’ content will be updated more often, so we can’t use the same approach for the calls to Superfeedr’s API. Yet, we still want the best experience so we have to cache the content and show it to the user immediately. In a way, for each call to the API, we want to achieve 2 things at <strong>concurrently</strong>:</p> <ul> <li>If there is any data in the cache, show that to the user</li> <li>Make a request to Superfeedr’s API and fail silently if the application is offline.</li> </ul> <p>That’s a pretty common scenario in the <a href="https://jakearchibald.com/2014/offline-cookbook/">Offline Cookbook</a> published by <a href="https://twitter.com/jaffathecake">Jake Archibald</a>. As a consequence, Google implemented it in its <a href="https://github.com/GoogleChrome/sw-toolbox">sw-toolbox</a> (<code>sw-toolbox</code> is syntactic sugar on top of Service Workers, exactly like <a href="https://github.com/GoogleChrome/sw-precache">sw-precache</a>. The scenario we described above is called <code>fastest</code>.</p> <p><code>sw-toolbox</code> provides a routing mechanism which hijacks all HTTP requests performed by the browser and applies any of the predefined recipes in the toolbox. Here’s the code we’re using for River.news:</p> <pre data-line=""><code class="language-javascript">toolbox.router.get(/^https:\/\/push.superfeedr.com\//, toolbox.fastest); toolbox.router.get(/^https:\/\/www.google.com\/s2\/favicons/, toolbox.fastest); toolbox.router.get(/^https:\/\/river.news\/up.html/, toolbox.networkOnly);</code></pre> <p>We see that for any request which matches the <code>/^https:\/\/push.superfeedr.com\//,</code> regular expression, we apply the <code>toolbox.fastest</code> recipe. We use the exact same approach for requests to <code>google.com/s2/favicons</code> that we use to load the icons for each story.</p> <p>The last line is a bit different. We <em>only</em> want to load this last resource using the network and never cache it.</p> <h2 id="assessing-connectivity">Assessing connectivity</h2> <p>Caching data is extremely useful when the application <strong>only has to display</strong> information. However, if the local application needs to alter the data, caching can quickly turn into an engineering nightmare with race conditions, lost updates and more. Luckily for us, a feed reader is mostly about <em>consuming</em> data and rarely about <em>altering</em> it. The notable exception being that one might want to update their subscription list. To make things simpler, at this point, we want to disable any change to the subscription list while the application is offline.</p> <blockquote> <p>HTML5 has its own <a href="http://w3c.github.io/netinfo/">Network Information API</a>. Not only is it <a href="http://caniuse.com/#feat=netinfo">barely implemented</a>, it also fails to detect when the device on which our application is connected to a network, but not to the web.</p> </blockquote> <p>In order to check if we can update our subscription list, the River.news application will just make a simple <code>HEAD</code> request to <a href="http://river.news/up.html"><code>http://river.news/up.html</code></a>. If the request fails, we assume that we’re offline and then disable the form fields. If it succeeds we can let the user add or remove feeds.</p> <p>The latest rule of our <code>sw-toolbox</code> should now make sense: we cannot afford to cache the responses if we want to reliably detect when we are offline!</p> <p>There are <em>many</em> other use cases to Service Workers. For example, in our feed reader, we could use Service Workers to white-list a set of 3rd party javascript script.</p>
		</content>
		<author>
			<name>Julien</name>
			<uri>http://ouvre-boite.com</uri>
		</author>
	</entry>
	<entry>
		<title>
			Adding Offline Support to a feed reader with Service Workers
		</title>
		<link href="http://blog.superfeedr.com/service-workers/"/>
		<published>2016-01-12T00:00:00-05:00</published>
		<updated>2016-01-12T00:00:00-05:00</updated>
		<id>blog.superfeedr.com:/service-workers</id>
		<summary>
			Feed readers are more useful when they work offline. Unfortunately, up until a couple months ago, the web’s technologies were not compatible with this requirement. Yet, the introduction of Service Workers is slowly changing this game and, at Superfeedr, we’re excited to see open web technologies catch up with capabilities of installable native apps.
		</summary>
		<content type="html">
			<p>Feed readers are more useful when they <strong>work offline</strong>. Unfortunately, up until a couple months ago, the web’s technologies were not compatible with this requirement. Yet, the introduction of <a href="http://www.w3.org/TR/service-workers/">Service Workers</a> is slowly changing this game and, at <a href="https://superfeedr.com">Superfeedr</a>, we’re excited to see open web technologies catch up with capabilities of installable native apps.</p> <p>We have our very own RSS reader built on top of Superfeedr’s API: <a href="https://superfeedr.com">river.news</a>. Let’s see what Service Workers can do for it and improve our code. As a reminder, this is a <strong>static single page application</strong>: there’s no application server which computes a different response for each request. Check the <a href="https://github.com/superfeedr/river.news">source code</a> on Github.</p> <h2 id="service-workers">Service Workers</h2> <p>Dozens of <a href="https://changelog.com/must-watch-videos-service-workers/">great</a> <a href="https://changelog.com/essential-reading-list-for-getting-started-with-service-workers/">resources</a> online provide excellent definitions and introductions to Service Workers. To us, it’s a <em>very significant upgrade to the web’s core philosophy</em>. The web’s center is the <a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol">HTTP protocol</a> which stands for <strong>H</strong>yper<strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol. Literally, this means our browsers are communicating with servers to receive <strong>hyper-text document</strong>: the web pages. Later, these documents may load Javascript code which is finally executed. With ServiceWorkers, the <strong>order changes</strong>: some javascript code can be executed <em>before</em> anything else happens. These workers can then hijack HTTP request (and more) and provide alternative (or fallback) responses.</p> <p>Adding support to river.news would be very interesting on 2 levels:</p> <ul> <li>Since the code is static, there’s <em>no need</em> to load it from the file server after its first load. <a href="https://subtome.com">SubToMe</a> used AppCache for this…. but AppCache <a href="http://alistapart.com/article/application-cache-is-a-douchebag">is so messy</a>.</li> <li>When loading past stories from Superfeedr, we should keep them in the cache so that the user can read them even when they go offline or have a spotty connection.</li> </ul> <h2 id="an-application-shell">An application shell</h2> <p>Most web applications have a <strong>base template</strong> which is made of some HTML, CSS and Javascript used all across the application, even if there are multiple HTML pages. This <strong>application shell</strong> should absolutely be cached by the browser so that it stays in memory. There should be no latency spent downloading it because it rarely changes.</p> <p>In the case of <a href="https://river.news">river.news</a>, it’s actually fairly simple: there’s just a <em>single HTML page</em>. There’s also a single javascript file for the application’s specific code. Since we use React and Jquery as dependencies, we consider them as part of the basic shell for our application. We also use Bootstrap’s CSS, so we’ll add it to the shell, as well as a bunch of icons.</p> <p>The application’s shell must immediately be cached the first time the page is loaded and we should only invalidate the cache for the files that have changed (incremental updates are much better than native apps!). Even though the Service Worker API is fairly simple, the Chrome team provides some syntactic sugar in the form of <a href="https://github.com/GoogleChrome/sw-precache"><code>sw-precache</code></a>. This script lets anyone quickly define the files required for the shell and handles invalidation without <strong>any significant code change</strong> to your own code!</p> <p>That was the easy part. Next week, we’ll see how we can also cache the API calls to Superfeedr for offline usage!</p>
		</content>
		<author>
			<name>Julien</name>
			<uri>http://ouvre-boite.com</uri>
		</author>
	</entry>

	<entry>
		<title>
			Adding Offline Support to a feed reader with Service Workers
		</title>
		<link href="http://blog.superfeedr.com/service-workers/"/>
		<published>2016-01-12T00:00:00-05:00</published>
		<updated>2016-01-12T00:00:00-05:00</updated>
		<id>blog.superfeedr.com:/service-workers</id>
		<summary>
			Feed readers are more useful when they work offline. Unfortunately, up until a couple months ago, the web’s technologies were not compatible with this requirement. Yet, the introduction of Service Workers is slowly changing this game and, at Superfeedr, we’re excited to see open web technologies catch up with capabilities of installable native apps.
		</summary>
		<content type="html">
			<p>Feed readers are more useful when they <strong>work offline</strong>. Unfortunately, up until a couple months ago, the web’s technologies were not compatible with this requirement. Yet, the introduction of <a href="http://www.w3.org/TR/service-workers/">Service Workers</a> is slowly changing this game and, at <a href="https://superfeedr.com">Superfeedr</a>, we’re excited to see open web technologies catch up with capabilities of installable native apps.</p> <p>We have our very own RSS reader built on top of Superfeedr’s API: <a href="https://superfeedr.com">river.news</a>. Let’s see what Service Workers can do for it and improve our code. As a reminder, this is a <strong>static single page application</strong>: there’s no application server which computes a different response for each request. Check the <a href="https://github.com/superfeedr/river.news">source code</a> on Github.</p> <h2 id="service-workers">Service Workers</h2> <p>Dozens of <a href="https://changelog.com/must-watch-videos-service-workers/">great</a> <a href="https://changelog.com/essential-reading-list-for-getting-started-with-service-workers/">resources</a> online provide excellent definitions and introductions to Service Workers. To us, it’s a <em>very significant upgrade to the web’s core philosophy</em>. The web’s center is the <a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol">HTTP protocol</a> which stands for <strong>H</strong>yper<strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol. Literally, this means our browsers are communicating with servers to receive <strong>hyper-text document</strong>: the web pages. Later, these documents may load Javascript code which is finally executed. With ServiceWorkers, the <strong>order changes</strong>: some javascript code can be executed <em>before</em> anything else happens. These workers can then hijack HTTP request (and more) and provide alternative (or fallback) responses.</p> <p>Adding support to river.news would be very interesting on 2 levels:</p> <ul> <li>Since the code is static, there’s <em>no need</em> to load it from the file server after its first load. <a href="https://subtome.com">SubToMe</a> used AppCache for this…. but AppCache <a href="http://alistapart.com/article/application-cache-is-a-douchebag">is so messy</a>.</li> <li>When loading past stories from Superfeedr, we should keep them in the cache so that the user can read them even when they go offline or have a spotty connection.</li> </ul> <h2 id="an-application-shell">An application shell</h2> <p>Most web applications have a <strong>base template</strong> which is made of some HTML, CSS and Javascript used all across the application, even if there are multiple HTML pages. This <strong>application shell</strong> should absolutely be cached by the browser so that it stays in memory. There should be no latency spent downloading it because it rarely changes.</p> <p>In the case of <a href="https://river.news">river.news</a>, it’s actually fairly simple: there’s just a <em>single HTML page</em>. There’s also a single javascript file for the application’s specific code. Since we use React and Jquery as dependencies, we consider them as part of the basic shell for our application. We also use Bootstrap’s CSS, so we’ll add it to the shell, as well as a bunch of icons.</p> <p>The application’s shell must immediately be cached the first time the page is loaded and we should only invalidate the cache for the files that have changed (incremental updates are much better than native apps!). Even though the Service Worker API is fairly simple, the Chrome team provides some syntactic sugar in the form of <a href="https://github.com/GoogleChrome/sw-precache"><code>sw-precache</code></a>. This script lets anyone quickly define the files required for the shell and handles invalidation without <strong>any significant code change</strong> to your own code!</p> <p>That was the easy part. Next week, we’ll see how we can also cache the API calls to Superfeedr for offline usage!</p>
		</content>
		<author>
			<name>Julien12121299</name>
			<uri>http://ouvre-boite.com</uri>
		</author>
	</entry>
</feed>